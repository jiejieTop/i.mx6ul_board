/** signal.c */

/**
 * 信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。
 * 信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。
 * 它可以在任何时候发给某一进程，而无需知道该进程的状态。如果该进程当前并未处于执行态，则该信号就由内核保存起来，
 * 直到该进程恢复执行再传递给它为止；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。
 * 
 * kill 命令中 “−l” 选项，可以列出该系统所支持的所有信号的列表。
 * 信号值在 32 之前的则有不同的名称，而信号值在 32 以后的都是用“SIGRTMIN”或“SIGRTMAX”开头的，这就是两类典型的信号。
 * 前者是从 UNIX 系统中继承下来的信号，为不可靠信号（也称为非实时信号）；
 * 后者是为了解决前面“不可靠信号”的问题而进行了更改和扩充的信号，称为“可靠信号”（也称为实时信号）。
 * 
 * 一个不可靠信号的处理过程是这样的： 如果发现该信号已经在进程中注册， 那么就忽略该信号。
 * 因此，若前一个信号还未注销又产生了相同的信号就会产生信号丢失。而当可靠信号发送给一个进程时，不管该信号是否已经
 * 在进程中注册，都会被再注册一次，因此信号就不会丢失。所有可靠信号都支持排队，而所有不可靠信号都不支持排队。
 * 
 * 用户进程对信号的响应可以有 3 种方式:
 *   忽略信号，即对信号不做任何处理，但是有两个信号不能忽略，即 SIGKILL 及 SIGSTOP。
 *   捕捉信号，定义信号处理函数，当信号发生时，执行相应的自定义处理函数。
 *   执行缺省操作， Linux 对每种信号都规定了默认操作。
 * 
 * 常见信号的含义及其默认操作：
 * 信 号 名                     含 义                               默 认 操 作
 * 
 * SIGHUP       该信号在用户终端连接（正常或非正常）结束时发出，              终止
 *              通常是在终端的控 制进程结束时，通知同一会话内的      
 *              各个作业与控制终端不再关联 
 * 
 * SIGINT       该信号在用户键入 INTR 字符（通常是 Ctrl-C）时发出，         终止
 *              终端驱动程序发送此信号并送到前台进程中的每一个进程            
 * 
 * SIGQUIT      该信号和 SIGINT 类似，                                  终止
 *              但由 QUIT 字符（通常是 Ctrl-\）来控制                     
 * 
 * SIGILL       该信号在一个进程企图执行一条非法指令时（可执行文件本          终止
 *              身出现错误，或者试图执行数据段、堆栈溢出时）发出 
 * 
 * SIGFPE       该信号在发生致命的算术运算错误时发出。这里不仅包括浮点        终止  
 *              运算错误，还包括溢出及除数为 0 等其他所有的算术错误         
 * 
 * SIGKILL      该信号用来立即结束程序的运行，                            终止
 *              并且不能被阻塞、处理或忽略
 * 
 * SIGALRM      该信号当一个定时器到时的时候发出                          终止
 * 
 * SIGSTOP      该信号用于暂停一个进程，且不能被阻塞、处理或忽略            暂停进程
 * 
 * SIGTSTP      该信号用于交互停止进程，用户键入 SUSP 字符时              停止进程
 *              （通常是 Ctrl+Z）发出这个信号                       
 * 
 * SIGCHLD      子进程改变状态时，父进程会收到这个信号                     忽略
 * 
 * SIGABORT      进程异常终止时发出
 */

/**
 * kill()函数同读者熟知的 kill 系统命令一样， 可以发送信号给进程或进程组（实际上， kill 系统命令只是 kill()
 * 函数的一个用户接口）。这里需要注意的是，它不仅可以中止进程（实际上发出 SIGKILL 信号），也可以向进程发送其他信号。
 * 
 * 函数原型 : int kill(pid_t pid, int sig)
 * 参数pid：
 *   正数：要发送信号的进程号
 *   0：信号被发送到所有和当前进程在同一个进程组的进程
 *   -1：信号发给所有的进程表中的进程（除了进程号最大的进程外）
 *   <-1：信号发送给进程组号为-pid 的每一个进程
 * 参数sig：发送的信号
 * 返回值：
 *   0：成功
 *   -1：失败
 * 
 * 与 kill()函数所不同的是， raise()函数允许进程向自身发送信号
 * 
 * 函数原型 int raise(int sig)
 * 函数传入值 sig：信号
 * 函数返回值：
 *   0：成功
 *   -1：失败
 */


#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

int main(void)
{
    pid_t pid;

    int ret;

    /* 创建一子进程 */
    if ((pid = fork()) < 0)
    {
        printf("Fork error\n");
        exit(1);
    }
    
    if (pid == 0)
    {
        /* 在子进程中使用 raise()函数发出 SIGSTOP 信号,使子进程暂停 */
        printf("Child(pid : %d) is waiting for any signal\n", getpid());

        raise(SIGSTOP);     /** 子进程停在这里 */

        exit(0);
    }

    else
    {
        sleep(1);       /** 等待一下，等子进程先执行 */

        /* 在父进程中收集子进程发出的信号(不阻塞)，并调用 kill()函数进行相应的操作 */
        if ((waitpid(pid, NULL, WNOHANG)) == 0)     
        {
            /** 子进程还没退出，返回为0，就发送SIGKILL信号杀死子进程 */
            if ((ret = kill(pid, SIGKILL)) == 0)
            {
                printf("Parent kill %d\n",pid);
            }
        }
        
        /** 一直阻塞直到子进程退出（杀死） */
        waitpid(pid, NULL, 0);

        exit(0);
    }
}

